# Spring boot
**Spring Boot** is a popular framework built on top of the **Spring Framework** that simplifies the development of stand-alone, production-grade Spring-based applications. It is designed to reduce the complexity of configuring and deploying Spring applications, allowing developers to focus more on writing business logic rather than boilerplate code.

1. **Spring Boot Basics**: Be prepared to explain what Spring Boot is and its advantages over traditional Spring.
2. **Dependency Injection**: Understand how DI works in Spring and its benefits.
3. **Spring MVC**: Be ready to discuss the MVC architecture and how it is implemented in Spring.
4. **RESTful Web Services**: Know how to create and consume REST APIs using Spring Boot.
5. **Spring Data JPA**: Understand how to interact with databases using JPA and Hibernate.
6. **Spring Security**: Be prepared to discuss how to secure a Spring Boot application.

### **What is Spring Boot?**
Spring Boot is an extension of the Spring Framework that provides:
1. **Auto-Configuration**: Automatically configures your application based on the dependencies you add.
2. **Stand-Alone Applications**: Allows you to create stand-alone Spring applications with embedded servers (e.g., Tomcat, Jetty).
3. **Production-Ready Features**: Includes features like health checks, metrics, and externalized configuration out of the box.
4. **Opinionated Defaults**: Provides sensible defaults for configuration, reducing the need for manual setup.

### **Advantages of Spring Boot Over Traditional Spring**

| Feature                  | **Spring Boot**                              | **Traditional Spring**                     |
|--------------------------|----------------------------------------------|--------------------------------------------|
| **Configuration**         | Auto-configuration reduces boilerplate code. | Requires manual configuration (e.g., XML, Java config). |
| **Embedded Server**       | Comes with embedded servers (e.g., Tomcat).  | Requires external server setup.            |
| **Dependency Management** | Simplifies dependency management with starter POMs. | Manual dependency management.             |
| **Production-Ready**      | Built-in support for metrics, health checks, etc. | Requires additional setup for production features. |
| **Development Speed**     | Faster development with opinionated defaults. | Slower due to manual configuration.       |
| **Deployment**            | Stand-alone JAR files for easy deployment.   | Requires WAR files and external servers.  |

### **Key Features of Spring Boot**

1. **Auto-Configuration**:
   - Spring Boot automatically configures your application based on the dependencies you include. For example, if you add `spring-boot-starter-web`, it automatically sets up a web application with an embedded Tomcat server.

2. **Starter POMs**:
   - Spring Boot provides a set of "starter" dependencies (e.g., `spring-boot-starter-web`, `spring-boot-starter-data-jpa`) that simplify dependency management. These starters include all the necessary dependencies for common use cases.

3. **Embedded Servers**:
   - Spring Boot applications can run with embedded servers like Tomcat, Jetty, or Undertow, eliminating the need for external server setup.

4. **Production-Ready Features**:
   - Spring Boot includes built-in support for monitoring and managing your application in production environments. Features like health checks, metrics, and externalized configuration are available out of the box.

5. **Stand-Alone Applications**:
   - Spring Boot applications can be packaged as stand-alone JAR files, making them easy to deploy and run.

### **Example: Creating a Simple Spring Boot Application**

1. **Add Dependencies** (in `pom.xml` for Maven):
   ```xml
   <dependencies>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
       </dependency>
   </dependencies>
   ```

2. **Create a Spring Boot Application**:
   ```java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RestController;

   @SpringBootApplication
   @RestController
   public class MyApplication {
       public static void main(String[] args) {
           SpringApplication.run(MyApplication.class, args);
       }

       @GetMapping("/hello")
       public String sayHello() {
           return "Hello, Spring Boot!";
       }
   }
   ```

3. **Run the Application**:
   - Run the `main` method in `MyApplication`. The application starts on port 8080 by default.
   - Access `http://localhost:8080/hello` in your browser to see the output: `Hello, Spring Boot!`.

### **Common Interview Questions**

1. **What is Spring Boot, and how is it different from the Spring Framework?**
   - Spring Boot is an extension of the Spring Framework that simplifies the development of Spring applications by providing auto-configuration, embedded servers, and production-ready features. Traditional Spring requires manual configuration and setup.

2. **What are the advantages of using Spring Boot?**
   - Faster development, simplified dependency management, embedded servers, production-ready features, and stand-alone applications.

3. **What is auto-configuration in Spring Boot?**
   - Auto-configuration automatically configures your application based on the dependencies you include, reducing the need for manual configuration.

4. **What are starter POMs in Spring Boot?**
   - Starter POMs are a set of dependencies that simplify dependency management by including all necessary dependencies for common use cases (e.g., `spring-boot-starter-web` for web applications).

5. **How does Spring Boot simplify deployment?**
   - Spring Boot applications can be packaged as stand-alone JAR files with embedded servers, making them easy to deploy and run.

# Dependency Injection (DI)
**Dependency Injection (DI)** is a core concept in the **Spring Framework** that promotes loose coupling and makes your code more modular, testable, and maintainable. Let's break down how DI works in Spring and its benefits.

### **What is Dependency Injection (DI)?**
Dependency Injection is a design pattern in which the dependencies of a class are provided (injected) by an external entity (e.g., the Spring container) rather than the class creating or managing its own dependencies.

- **Dependency**: An object that another object depends on (e.g., a service class used by a controller).
- **Injection**: The process of providing the dependency to the dependent object (e.g., passing a service object to a controller).

### **How Dependency Injection Works in Spring**
Spring implements DI using its **Inversion of Control (IoC)** container. The IoC container is responsible for:
1. **Creating objects** (beans).
2. **Managing dependencies** between objects.
3. **Injecting dependencies** into objects.

#### **Types of Dependency Injection in Spring**
1. **Constructor Injection**:
   - Dependencies are injected via the constructor.
   - Recommended for mandatory dependencies.

   **Example**:
   ```java
   @Service
   public class UserService {
       private final UserRepository userRepository;

       @Autowired // Constructor injection
       public UserService(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

2. **Setter Injection**:
   - Dependencies are injected via setter methods.
   - Suitable for optional dependencies.

   **Example**:
   ```java
   @Service
   public class UserService {
       private UserRepository userRepository;

       @Autowired // Setter injection
       public void setUserRepository(UserRepository userRepository) {
           this.userRepository = userRepository;
       }
   }
   ```

3. **Field Injection**:
   - Dependencies are injected directly into fields using reflection.
   - Less recommended because it makes testing harder and hides dependencies.

   **Example**:
   ```java
   @Service
   public class UserService {
       @Autowired // Field injection
       private UserRepository userRepository;
   }
   ```

### **Benefits of Dependency Injection**

1. **Loose Coupling**:
   - DI promotes loose coupling between classes. Classes depend on abstractions (interfaces) rather than concrete implementations, making the system more modular and flexible.

2. **Easier Testing**:
   - Dependencies can be easily mocked or stubbed in unit tests, making testing simpler and more effective.

3. **Reusability**:
   - Dependencies can be reused across multiple classes, reducing code duplication.

4. **Maintainability**:
   - Changes to dependencies are centralized in the Spring configuration, making the code easier to maintain.

5. **Configuration Management**:
   - Spring's IoC container manages the lifecycle and configuration of beans, reducing boilerplate code.

### **Example: Dependency Injection in Action**

#### **Step 1: Define Dependencies**
```java
public interface UserRepository {
    void save(User user);
}

@Repository
public class UserRepositoryImpl implements UserRepository {
    @Override
    public void save(User user) {
        System.out.println("User saved: " + user.getName());
    }
}
```

#### **Step 2: Inject Dependencies**
```java
@Service
public class UserService {
    private final UserRepository userRepository;

    @Autowired // Constructor injection
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void createUser(String name) {
        User user = new User(name);
        userRepository.save(user);
    }
}
```

#### **Step 3: Use the Service**
```java
@SpringBootApplication
public class MyApplication implements CommandLineRunner {
    @Autowired
    private UserService userService;

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

    @Override
    public void run(String... args) {
        userService.createUser("John Doe");
    }
}
```

#### **Step 4: Run the Application**
- When you run the application, Spring will:
  1. Create an instance of `UserRepositoryImpl`.
  2. Inject it into `UserService` via constructor injection.
  3. Call the `createUser` method, which saves the user.

### **Key Points to Remember**
1. **Spring IoC Container**:
   - Manages the lifecycle and dependencies of beans.
   - Uses annotations like `@Autowired` to inject dependencies.

2. **Types of Injection**:
   - Constructor injection (recommended for mandatory dependencies).
   - Setter injection (for optional dependencies).
   - Field injection (less recommended).

3. **Benefits of DI**:
   - Loose coupling, easier testing, reusability, maintainability, and centralized configuration.

### **Common Interview Questions**

1. **What is Dependency Injection (DI)?**
   - DI is a design pattern where dependencies are provided to a class by an external entity (e.g., Spring IoC container) rather than the class creating them itself.

2. **What are the types of Dependency Injection in Spring?**
   - Constructor injection, setter injection, and field injection.

3. **Why is Constructor Injection preferred?**
   - Constructor injection ensures that all mandatory dependencies are provided at the time of object creation, making the class immutable and easier to test.

4. **What is the role of the Spring IoC container?**
   - The Spring IoC container manages the lifecycle of beans and injects dependencies into them.

5. **What are the benefits of Dependency Injection?**
   - Loose coupling, easier testing, reusability, maintainability, and centralized configuration.

6. **What is the difference between `@Autowired` and `@Resource`?**
   - `@Autowired` is Spring-specific and injects by type. `@Resource` is Java EE-specific and injects by name.

# Annotations
**Spring Boot** provides a wide range of annotations that simplify the development of Spring-based applications. These annotations reduce the need for boilerplate code and make it easier to configure and manage your application. Below is a list of commonly used Spring Boot annotations, categorized by their purpose:

### **Core Spring Boot Annotations**

1. **`@SpringBootApplication`**:
   - Combines `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`.
   - Marks the main class of a Spring Boot application.

   **Example**:
   ```java
   @SpringBootApplication
   public class MyApplication {
       public static void main(String[] args) {
           SpringApplication.run(MyApplication.class, args);
       }
   }
   ```

2. **`@Configuration`**:
   - Indicates that the class can be used as a source of bean definitions.
   - Often used with `@Bean` to define beans.

   **Example**:
   ```java
   @Configuration
   public class AppConfig {
       @Bean
       public MyService myService() {
           return new MyService();
       }
   }
   ```

3. **`@ComponentScan`**:
   - Configures component scanning directives for finding and registering beans in the application context.
   - Automatically scans for components (e.g., `@Component`, `@Service`, `@Repository`) in the specified package.

   **Example**:
   ```java
   @ComponentScan(basePackages = "com.example")
   public class MyApplication {
   }
   ```

4. **`@EnableAutoConfiguration`**:
   - Enables Spring Boot's auto-configuration mechanism, which automatically configures the application based on the dependencies in the classpath.

   **Example**:
   ```java
   @EnableAutoConfiguration
   public class MyApplication {
   }
   ```

### **Stereotype Annotations (Component Scanning)**

1. **`@Component`**:
   - Marks a class as a Spring bean. It is a generic stereotype for any Spring-managed component.

   **Example**:
   ```java
   @Component
   public class MyComponent {
   }
   ```

2. **`@Service`**:
   - Indicates that the class is a service component in the business layer.
   - Specialized form of `@Component`.

   **Example**:
   ```java
   @Service
   public class MyService {
   }
   ```

3. **`@Repository`**:
   - Marks the class as a repository (data access object) in the persistence layer.
   - Specialized form of `@Component`.

   **Example**:
   ```java
   @Repository
   public class MyRepository {
   }
   ```

4. **`@Controller`**:
   - Marks the class as a controller in the presentation layer (e.g., for handling HTTP requests).
   - Specialized form of `@Component`.

   **Example**:
   ```java
   @Controller
   public class MyController {
   }
   ```

5. **`@RestController`**:
   - Combines `@Controller` and `@ResponseBody`.
   - Used for creating RESTful web services.

   **Example**:
   ```java
   @RestController
   public class MyRestController {
       @GetMapping("/hello")
       public String sayHello() {
           return "Hello, World!";
       }
   }
   ```

### **Dependency Injection Annotations**

1. **`@Autowired`**:
   - Injects dependencies automatically by type.
   - Can be used on fields, constructors, or setter methods.

   **Example**:
   ```java
   @Service
   public class MyService {
       @Autowired
       private MyRepository myRepository;
   }
   ```

2. **`@Qualifier`**:
   - Used with `@Autowired` to specify which bean to inject when multiple beans of the same type exist.

   **Example**:
   ```java
   @Service
   public class MyService {
       @Autowired
       @Qualifier("myRepositoryImpl")
       private MyRepository myRepository;
   }
   ```

3. **`@Primary`**:
   - Indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency.

   **Example**:
   ```java
   @Component
   @Primary
   public class MyRepositoryImpl implements MyRepository {
   }
   ```

4. **`@Value`**:
   - Injects values from properties files or environment variables into fields.

   **Example**:
   ```java
   @Component
   public class MyComponent {
       @Value("${app.name}")
       private String appName;
   }
   ```

### **Web Annotations (REST and MVC)**

1. **`@RequestMapping`**:
   - Maps HTTP requests to handler methods in a controller.
   - Can be used at the class or method level.

   **Example**:
   ```java
   @RestController
   @RequestMapping("/api")
   public class MyController {
       @RequestMapping("/hello")
       public String sayHello() {
           return "Hello, World!";
       }
   }
   ```

2. **`@GetMapping`**, **`@PostMapping`**, **`@PutMapping`**, **`@DeleteMapping`**:
   - Shortcut annotations for `@RequestMapping` with specific HTTP methods.

   **Example**:
   ```java
   @RestController
   public class MyController {
       @GetMapping("/hello")
       public String sayHello() {
           return "Hello, World!";
       }
   }
   ```

3. **`@PathVariable`**:
   - Extracts values from the URI template.

   **Example**:
   ```java
   @GetMapping("/users/{id}")
   public String getUser(@PathVariable Long id) {
       return "User ID: " + id;
   }
   ```

4. **`@RequestParam`**:
   - Extracts query parameters from the URL.

   **Example**:
   ```java
   @GetMapping("/users")
   public String getUser(@RequestParam String name) {
       return "User Name: " + name;
   }
   ```

5. **`@RequestBody`**:
   - Binds the body of the HTTP request to a Java object.

   **Example**:
   ```java
   @PostMapping("/users")
   public String createUser(@RequestBody User user) {
       return "User created: " + user.getName();
   }
   ```

6. **`@ResponseBody`**:
   - Indicates that the return value of a method should be used as the response body.

   **Example**:
   ```java
   @GetMapping("/hello")
   @ResponseBody
   public String sayHello() {
       return "Hello, World!";
   }
   ```

### **Configuration and Properties**

1. **`@ConfigurationProperties`**:
   - Binds external configuration properties (e.g., from `application.properties`) to a Java object.

   **Example**:
   ```java
   @ConfigurationProperties(prefix = "app")
   public class AppConfig {
       private String name;
       // Getters and setters
   }
   ```

2. **`@PropertySource`**:
   - Specifies the location of a properties file to be loaded into the Spring environment.

   **Example**:
   ```java
   @Configuration
   @PropertySource("classpath:app.properties")
   public class AppConfig {
   }
   ```


### **Testing Annotations**

1. **`@SpringBootTest`**:
   - Used for integration testing in Spring Boot applications.

   **Example**:
   ```java
   @SpringBootTest
   public class MyIntegrationTest {
   }
   ```

2. **`@MockBean`**:
   - Adds a mock of a bean to the Spring application context.

   **Example**:
   ```java
   @SpringBootTest
   public class MyServiceTest {
       @MockBean
       private MyRepository myRepository;
   }
   ```


### **Other Useful Annotations**

1. **`@Profile`**:
   - Specifies that a component is eligible for registration only if a specific profile is active.

   **Example**:
   ```java
   @Component
   @Profile("dev")
   public class DevDataSource {
   }
   ```

2. **`@Scheduled`**:
   - Marks a method to be executed on a fixed schedule.

   **Example**:
   ```java
   @Scheduled(fixedRate = 5000)
   public void runTask() {
       System.out.println("Task executed");
   }
   ```

### **Summary**
Spring Boot annotations simplify development by reducing boilerplate code and providing sensible defaults. They cover a wide range of use cases, including dependency injection, web development, configuration, and testing.

# ApplicationContext

The **Spring Boot context** refers to the **ApplicationContext** in a Spring Boot application, which is the central interface for managing the lifecycle of beans, dependency injection, and configuration. The ApplicationContext is essentially the Spring IoC (Inversion of Control) container that holds all the beans (objects) and their dependencies, and it is responsible for creating, configuring, and managing these beans.

In Spring Boot, the context is automatically set up and configured, making it easier to develop and deploy applications. Let's break down the key aspects of the Spring Boot context:

### **1. What is the Spring Boot Context?**
- The **ApplicationContext** is the core of a Spring Boot application. It is responsible for:
  - **Bean Management**: Creating, configuring, and managing beans (objects) in the application.
  - **Dependency Injection (DI)**: Injecting dependencies into beans.
  - **Configuration**: Loading configuration properties and managing profiles.
  - **Event Handling**: Publishing and listening to application events.
  - **Resource Management**: Accessing resources like files, URLs, etc.

- In Spring Boot, the context is initialized automatically when the application starts, and it is configured based on the dependencies and settings in the application.

### **2. How is the Spring Boot Context Created?**
- The Spring Boot context is created when the application starts, typically via the `SpringApplication.run()` method in the main class.
- The context is built using **auto-configuration** and **component scanning**, which are key features of Spring Boot.

**Example**:
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(MyApplication.class, args);
    }
}
```
- Here, `SpringApplication.run()` initializes the Spring Boot context and returns an instance of `ApplicationContext`.

### **3. Key Features of the Spring Boot Context**

#### **Auto-Configuration**
- Spring Boot automatically configures the context based on the dependencies in the classpath.
- For example, if you include `spring-boot-starter-web`, Spring Boot automatically configures a web application context with an embedded Tomcat server.

#### **Component Scanning**
- Spring Boot scans for components (e.g., `@Component`, `@Service`, `@Repository`, `@Controller`) in the specified packages and registers them as beans in the context.
- By default, Spring Boot scans the package of the main class and its sub-packages.

#### **Externalized Configuration**
- Spring Boot allows you to externalize configuration using properties files (e.g., `application.properties` or `application.yml`).
- The context loads these configurations and makes them available for dependency injection using `@Value` or `@ConfigurationProperties`.

#### **Profiles**
- Spring Boot supports **profiles**, which allow you to define different configurations for different environments (e.g., `dev`, `prod`).
- The context activates the appropriate profile based on the `spring.profiles.active` property.

#### **Bean Lifecycle Management**
- The context manages the lifecycle of beans, including their creation, initialization, and destruction.
- You can use annotations like `@PostConstruct` and `@PreDestroy` to define lifecycle callbacks.


### **4. Accessing the Spring Boot Context**
You can access the Spring Boot context in several ways:

#### **1. Using `ApplicationContext` in the Main Class**
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(MyApplication.class, args);
        MyService myService = context.getBean(MyService.class);
        myService.doSomething();
    }
}
```

#### **2. Injecting `ApplicationContext` into a Bean**
```java
@Service
public class MyService {
    @Autowired
    private ApplicationContext context;

    public void doSomething() {
        MyRepository repository = context.getBean(MyRepository.class);
        repository.save();
    }
}
```

#### **3. Using `@Autowired` to Inject Beans**
```java
@Service
public class MyService {
    @Autowired
    private MyRepository myRepository;

    public void doSomething() {
        myRepository.save();
    }
}
```

### **5. Spring Boot Context Hierarchy**
Spring Boot supports a **hierarchical context** structure, where you can have a **parent context** and a **child context**:
- The **parent context** typically contains shared beans (e.g., services, repositories).
- The **child context** is often used for web-specific beans (e.g., controllers).

**Example**:
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplicationBuilder builder = new SpringApplicationBuilder(MyApplication.class);
        builder.parent(ParentConfig.class).child(ChildConfig.class).run(args);
    }
}
```


### **6. Spring Boot Context Events**
The Spring Boot context publishes several events during its lifecycle, which you can listen to and handle:
- **ApplicationStartingEvent**: Published when the application starts.
- **ApplicationReadyEvent**: Published when the application is ready to serve requests.
- **ApplicationFailedEvent**: Published if the application fails to start.

**Example**:
```java
@Component
public class MyContextListener implements ApplicationListener<ApplicationReadyEvent> {
    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        System.out.println("Application is ready!");
    }
}
```

### **7. Customizing the Spring Boot Context**
You can customize the Spring Boot context by:
- **Defining custom beans** using `@Bean` in a `@Configuration` class.
- **Overriding auto-configuration** using `@Conditional` annotations.
- **Adding custom properties** in `application.properties` or `application.yml`.

**Example**:
```java
@Configuration
public class MyConfig {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}
```

### **8. Common Interview Questions**

1. **What is the Spring Boot context?**
   - The Spring Boot context is the `ApplicationContext` that manages the lifecycle of beans, dependency injection, and configuration in a Spring Boot application.

2. **How is the Spring Boot context initialized?**
   - The context is initialized when the application starts, typically via the `SpringApplication.run()` method.

3. **What is auto-configuration in Spring Boot?**
   - Auto-configuration automatically configures the context based on the dependencies in the classpath.

4. **How do you access the Spring Boot context?**
   - You can access the context by injecting it using `@Autowired` or by calling `SpringApplication.run()`.

5. **What are Spring Boot profiles?**
   - Profiles allow you to define different configurations for different environments (e.g., `dev`, `prod`).

6. **What are some common Spring Boot context events?**
   - `ApplicationStartingEvent`, `ApplicationReadyEvent`, and `ApplicationFailedEvent`.

# Spring boot exception handling
Exception handling is a critical aspect of building robust and maintainable applications. In **Spring Boot**, advanced exception handling techniques allow you to manage errors gracefully, provide meaningful responses to clients, and maintain a clean separation of concerns. Let's dive into advanced exception handling in Spring Boot, including global exception handling, custom exceptions, and response customization.

### **1. Global Exception Handling with `@ControllerAdvice`**
Spring Boot provides the `@ControllerAdvice` annotation to define global exception handlers that apply to all controllers in your application. This is useful for centralizing exception handling logic.

#### **Steps to Implement Global Exception Handling**:
1. Create a class annotated with `@ControllerAdvice`.
2. Define methods annotated with `@ExceptionHandler` to handle specific exceptions.
3. Use `@ResponseStatus` to specify the HTTP status code for the response.

**Example**:
```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

@ControllerAdvice
public class GlobalExceptionHandler {

    // Handle specific exception
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ResponseEntity<String> handleResourceNotFoundException(ResourceNotFoundException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }

    // Handle generic exceptions
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        return new ResponseEntity<>("An error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

- **Explanation**:
  - The `@ControllerAdvice` annotation makes this class a global exception handler.
  - The `@ExceptionHandler` annotation specifies which exception the method handles.
  - The `@ResponseStatus` annotation sets the HTTP status code for the response.


### **2. Custom Exceptions**
Creating custom exceptions allows you to define specific error scenarios in your application. Custom exceptions should extend `RuntimeException` or any other exception class.

**Example**:
```java
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
```

- **Usage**:
  - Throw this exception in your service or controller when a resource is not found.
  - The global exception handler (`@ControllerAdvice`) will catch and handle it.


### **3. Custom Error Responses**
Instead of returning plain text, you can return a structured JSON response for errors. This is useful for APIs where clients expect consistent error formats.

**Example**:
```java
public class ErrorResponse {
    private int status;
    private String message;
    private long timestamp;

    // Constructor, getters, and setters
}
```

- **Update the Global Exception Handler**:
```java
@ExceptionHandler(ResourceNotFoundException.class)
@ResponseStatus(HttpStatus.NOT_FOUND)
public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException ex) {
    ErrorResponse errorResponse = new ErrorResponse();
    errorResponse.setStatus(HttpStatus.NOT_FOUND.value());
    errorResponse.setMessage(ex.getMessage());
    errorResponse.setTimestamp(System.currentTimeMillis());
    return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
}
```

- **Response**:
```json
{
    "status": 404,
    "message": "Resource not found",
    "timestamp": 1633024800000
}
```


### **4. Handling Validation Errors**
Spring Boot provides built-in support for validating request payloads using **Bean Validation (JSR 380)**. When validation fails, Spring throws a `MethodArgumentNotValidException`, which you can handle globally.

**Example**:
```java
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;

@ExceptionHandler(MethodArgumentNotValidException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
    Map<String, String> errors = new HashMap<>();
    ex.getBindingResult().getAllErrors().forEach(error -> {
        String fieldName = ((FieldError) error).getField();
        String errorMessage = error.getDefaultMessage();
        errors.put(fieldName, errorMessage);
    });
    return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
}
```

- **Response**:
```json
{
    "firstName": "First name is required",
    "email": "Invalid email format"
}
```


### **5. Handling Specific HTTP Status Codes**
You can use the `@ResponseStatus` annotation to map exceptions to specific HTTP status codes.

**Example**:
```java
@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Resource not found")
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
```

- **Usage**:
  - When this exception is thrown, Spring Boot automatically returns a `404 Not Found` response with the specified reason.


### **6. Logging Exceptions**
Logging exceptions is crucial for debugging and monitoring. You can log exceptions in your global exception handler.

**Example**:
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@ControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        logger.error("An error occurred: ", ex);
        return new ResponseEntity<>("An error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### **7. Handling Exceptions in REST Controllers**
You can also handle exceptions locally within a specific controller using `@ExceptionHandler`.

**Example**:
```java
@RestController
public class MyController {

    @GetMapping("/resource/{id}")
    public String getResource(@PathVariable Long id) {
        if (id == 0) {
            throw new ResourceNotFoundException("Resource not found");
        }
        return "Resource found";
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ResponseEntity<String> handleResourceNotFoundException(ResourceNotFoundException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }
}
```

### **8. Common Interview Questions**

1. **What is `@ControllerAdvice` in Spring Boot?**
   - `@ControllerAdvice` is a global exception handler that applies to all controllers in the application.

2. **How do you create custom exceptions in Spring Boot?**
   - Create a class that extends `RuntimeException` and add a constructor to pass error messages.

3. **How do you handle validation errors in Spring Boot?**
   - Use `@ExceptionHandler(MethodArgumentNotValidException.class)` to handle validation errors and return structured error responses.

4. **What is the difference between `@ExceptionHandler` and `@ControllerAdvice`?**
   - `@ExceptionHandler` is used for local exception handling within a controller, while `@ControllerAdvice` is used for global exception handling.

5. **How do you log exceptions in Spring Boot?**
   - Use a logging framework like SLF4J or Logback to log exceptions in the global exception handler.

6. **How do you return custom error responses in Spring Boot?**
   - Create a custom error response class and return it from the exception handler using `ResponseEntity`.


