# ðŸ”‘ Core Design Patterns Every Engineer Should Know

### **1. Creational Patterns** (object creation)

* **Singleton** â†’ Ensure only one instance of a class exists (e.g., configuration, logging, connection pools).
* **Factory Method** â†’ Delegate object creation without specifying exact class (useful when types may vary at runtime).
* **Abstract Factory** â†’ Create families of related objects (e.g., UI toolkit themes).
* **Builder** â†’ Step-by-step construction of complex objects (e.g., constructing JSON, SQL queries, or objects with many optional params).
* **Prototype** â†’ Clone existing objects instead of creating new ones from scratch (useful when object creation is costly).

### **2. Structural Patterns** (composition of classes/objects)

* **Adapter** â†’ Convert one interface to another (e.g., legacy system integration).
* **Bridge** â†’ Separate abstraction from implementation (useful for APIs with multiple backends).
* **Composite** â†’ Represent part-whole hierarchies (e.g., tree structures like DOM, menus).
* **Decorator** â†’ Add responsibilities dynamically without changing class (e.g., middleware, I/O streams).
* **Facade** â†’ Provide a simple interface to a complex system (e.g., unified API over multiple services).
* **Proxy** â†’ Act as a placeholder/representative for another object (e.g., caching, lazy loading, remote services).

### **3. Behavioral Patterns** (object communication)

* **Observer / Publish-Subscribe** â†’ Notify multiple dependents of state changes (e.g., event-driven systems, message buses).
* **Strategy** â†’ Define interchangeable algorithms (e.g., sorting, authentication strategies).
* **Command** â†’ Encapsulate requests as objects (e.g., undo/redo, job queues).
* **State** â†’ Allow objects to change behavior based on internal state (e.g., workflow engines).
* **Chain of Responsibility** â†’ Pass requests along a chain until handled (e.g., request filters, middleware).
* **Template Method** â†’ Define skeleton of algorithm but let subclasses override parts (e.g., parsing different file formats).
* **Iterator** â†’ Sequentially access elements without exposing internal representation.
* **Mediator** â†’ Reduce direct communication between objects, centralizing interaction logic (e.g., UI form controllers).
* **Memento** â†’ Save/restore object state (e.g., checkpoints, undo systems).

## âš¡ Modern/Practical Extensions

Besides GoF patterns, todayâ€™s engineers also lean on:

* **Dependency Injection (DI)** â†’ Inversion of Control, improves testability & flexibility.
* **Repository Pattern** â†’ Abstract data persistence (commonly in enterprise apps).
* **Unit of Work** â†’ Manage database transactions consistently.
* **Event Sourcing** â†’ State changes stored as events for traceability.
* **CQRS** (Command Query Responsibility Segregation) â†’ Separate read/write models for scalability.

## âœ… If youâ€™re targeting **interviews or system design**, the most asked ones are:

* Singleton
* Factory
* Observer
* Strategy
* Decorator
* Proxy
* Facade
* Chain of Responsibility

